/**
 * L4YERCAK3 Webhook Utilities
 * Auto-generated by @l4yercak3/cli
 *
 * Utilities for handling webhook events from L4YERCAK3.
 */

import { createHmac, timingSafeEqual } from 'crypto';

export interface WebhookEvent<T = Record<string, unknown>> {
  id: string;
  type: WebhookEventType;
  timestamp: string;
  data: T;
  organizationId: string;
}

export type WebhookEventType =
  | 'contact.created'
  | 'contact.updated'
  | 'contact.deleted'
  | 'organization.created'
  | 'organization.updated'
  | 'event.created'
  | 'event.updated'
  | 'event.published'
  | 'event.cancelled'
  | 'attendee.registered'
  | 'attendee.checked_in'
  | 'attendee.cancelled'
  | 'form.submitted'
  | 'order.created'
  | 'order.paid'
  | 'order.refunded'
  | 'invoice.created'
  | 'invoice.sent'
  | 'invoice.paid'
  | 'invoice.overdue'
  | 'benefit_claim.submitted'
  | 'benefit_claim.approved'
  | 'benefit_claim.rejected'
  | 'benefit_claim.paid'
  | 'commission.calculated'
  | 'commission.paid'
  | 'certificate.issued';

export interface VerifyOptions {
  /** The raw request body as a string or Buffer */
  payload: string | Buffer;
  /** The signature from the X-L4yercak3-Signature header */
  signature: string;
  /** Your webhook secret from the L4YERCAK3 dashboard */
  secret: string;
  /** Tolerance in seconds for timestamp validation (default: 300 = 5 minutes) */
  tolerance?: number;
}

export class WebhookVerificationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WebhookVerificationError';
  }
}

/**
 * Verify a webhook signature and parse the event
 *
 * @example
 * ```ts
 * // In your Next.js API route
 * import { verifyWebhookSignature, WebhookEvent } from '@/lib/l4yercak3';
 *
 * export async function POST(req: Request) {
 *   const payload = await req.text();
 *   const signature = req.headers.get('x-l4yercak3-signature') || '';
 *
 *   try {
 *     const event = verifyWebhookSignature({
 *       payload,
 *       signature,
 *       secret: process.env.L4YERCAK3_WEBHOOK_SECRET!,
 *     });
 *
 *     switch (event.type) {
 *       case 'contact.created':
 *         // Handle new contact
 *         break;
 *       case 'order.paid':
 *         // Handle paid order
 *         break;
 *     }
 *
 *     return new Response('OK', { status: 200 });
 *   } catch (error) {
 *     console.error('Webhook error:', error);
 *     return new Response('Invalid signature', { status: 400 });
 *   }
 * }
 * ```
 */
export function verifyWebhookSignature<T = Record<string, unknown>>(
  options: VerifyOptions
): WebhookEvent<T> {
  const { payload, signature, secret, tolerance = 300 } = options;

  if (!signature) {
    throw new WebhookVerificationError('Missing signature header');
  }

  // Parse the signature header (format: t=timestamp,v1=signature)
  const parts = signature.split(',').reduce((acc, part) => {
    const [key, value] = part.split('=');
    acc[key] = value;
    return acc;
  }, {} as Record<string, string>);

  const timestamp = parts['t'];
  const signatureHash = parts['v1'];

  if (!timestamp || !signatureHash) {
    throw new WebhookVerificationError('Invalid signature format');
  }

  // Check timestamp tolerance
  const timestampNum = parseInt(timestamp, 10);
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - timestampNum) > tolerance) {
    throw new WebhookVerificationError('Timestamp outside tolerance window');
  }

  // Compute expected signature
  const payloadStr = typeof payload === 'string' ? payload : payload.toString('utf8');
  const signedPayload = `${timestamp}.${payloadStr}`;
  const expectedSignature = createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  // Constant-time comparison
  const expectedBuffer = Buffer.from(expectedSignature);
  const receivedBuffer = Buffer.from(signatureHash);

  if (expectedBuffer.length !== receivedBuffer.length) {
    throw new WebhookVerificationError('Invalid signature');
  }

  if (!timingSafeEqual(expectedBuffer, receivedBuffer)) {
    throw new WebhookVerificationError('Invalid signature');
  }

  // Parse and return the event
  try {
    return JSON.parse(payloadStr) as WebhookEvent<T>;
  } catch {
    throw new WebhookVerificationError('Invalid JSON payload');
  }
}

/**
 * Type guard helpers for specific webhook events
 */
export function isContactEvent(event: WebhookEvent): event is WebhookEvent<{ contact: unknown }> {
  return event.type.startsWith('contact.');
}

export function isEventEvent(event: WebhookEvent): event is WebhookEvent<{ event: unknown }> {
  return event.type.startsWith('event.');
}

export function isOrderEvent(event: WebhookEvent): event is WebhookEvent<{ order: unknown }> {
  return event.type.startsWith('order.');
}

export function isInvoiceEvent(event: WebhookEvent): event is WebhookEvent<{ invoice: unknown }> {
  return event.type.startsWith('invoice.');
}

export function isBenefitClaimEvent(event: WebhookEvent): event is WebhookEvent<{ claim: unknown }> {
  return event.type.startsWith('benefit_claim.');
}
